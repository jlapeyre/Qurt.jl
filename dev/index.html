<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Qurt.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Qurt.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Qurt"><span>Qurt</span></a></li><li><a class="tocitem" href="#Circuit-Elements"><span>Circuit Elements</span></a></li><li><a class="tocitem" href="#Circuits"><span>Circuits</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Nodes"><span>Nodes</span></a></li><li><a class="tocitem" href="#Builders"><span>Builders</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jlapeyre/Qurt.jl/blob/main/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Qurt.jl"><a class="docs-heading-anchor" href="#Qurt.jl">Qurt.jl</a><a id="Qurt.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Qurt.jl" title="Permalink"></a></h1><ul><li><a href="#Qurt.jl">Qurt.jl</a></li><li class="no-marker"><ul><li><a href="#Qurt">Qurt</a></li><li><a href="#Circuit-Elements">Circuit Elements</a></li><li><a href="#Circuits">Circuits</a></li><li><a href="#Interface">Interface</a></li><li><a href="#Nodes">Nodes</a></li><li><a href="#Builders">Builders</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="internals/#Internals">Internals</a></li><li class="no-marker"><ul><li><a href="internals/#Circuit-Elements">Circuit Elements</a></li><li><a href="internals/#Circuits">Circuits</a></li><li><a href="internals/#Interface">Interface</a></li><li><a href="internals/#Nodes">Nodes</a></li><li><a href="internals/#Builders">Builders</a></li></ul></li></ul><h2 id="Qurt"><a class="docs-heading-anchor" href="#Qurt">Qurt</a><a id="Qurt-1"></a><a class="docs-heading-anchor-permalink" href="#Qurt" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Qurt" href="#Qurt.Qurt"><code>Qurt.Qurt</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Qurt</code></pre><p>The toplevel module of the package <code>Qurt</code> for building and manipulating quantum circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/Qurt.jl#LL1-L6">source</a></section></article><h2 id="Circuit-Elements"><a class="docs-heading-anchor" href="#Circuit-Elements">Circuit Elements</a><a id="Circuit-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-Elements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements" href="#Qurt.Elements"><code>Qurt.Elements</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Elements</code></pre><p>Quantum circuit elements. These are enums, that is encoded essentially as integers. There is a <code>struct</code> below <code>ParamElement</code> that composes an <code>Element</code> with a parameter, or container of parameters. This is meant to be any kind of parameter, not just an angle. But it is no meant to carry around metadata that is unrelated to paramaterizing a parametric gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/elements.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements.X" href="#Qurt.Elements.X"><code>Qurt.Elements.X</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">X::Element</code></pre><p>The <code>X</code> gate circuit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/elements.jl#LL300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements.Y" href="#Qurt.Elements.Y"><code>Qurt.Elements.Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Y::Element</code></pre><p>The <code>Y</code> gate circuit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/elements.jl#LL307-L311">source</a></section></article><h2 id="Circuits"><a class="docs-heading-anchor" href="#Circuits">Circuits</a><a id="Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Circuits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit" href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circuit(nqubits::Integer, nclbits::Integer=0; global_phase=0.0)</code></pre><p>Create a circuit with <code>nqubits</code> qubits, <code>nclbits</code> clbits.</p><p>Pairs of input and output nodes connected by an edges are created for each quantum and classical bit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Qurt.Circuits: Circuit

julia&gt; Circuit(2, 2)
circuit {nq=2, ncl=2, nv=8, ne=4} Graphs.SimpleGraphs.SimpleDiGraph{Int64} Qurt.NodeStructs.Node{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL153-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit" href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circuit</code></pre><p>Structure for representing a quantum circuit as a DAG with data attached to vertices and edges.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> – The DAG as a <code>Graphs.DiGraph</code></li><li><code>nodes</code> – Operations and other nodes on vertices</li><li><code>nqubits</code> – Number of qubits.</li><li><code>nclbits</code> – Number of classical bits.</li></ul><p>The DAG is a <code>Graphs.DiGraph</code>, which maintains edge lists for forward and backward edges. An &quot;operation&quot; is associated with each vertex in the graph. Each vertex is identified by a positive integer. Each wire is identified by a positive integer.</p><p>The edge lists for vertex <code>i</code> are given by the <code>i</code>th element of the <code>Vector</code> of edge lists stored in the DAG.</p><p>The operation on vertex <code>i</code> is given by the <code>i</code>th element of the field <code>nodes</code>.</p><p>There is no meaning in the order of neighboring vertices in the edge lists, in fact they are sorted.</p><p>The number of wires is equal to <code>nqubits + nclbits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL104-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit-Tuple{}" href="#Qurt.Circuits.Circuit-Tuple{}"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Circuit(;global_phase=0.0)</code></pre><p>Create a circuit with no qubits, no clbits, and global phase equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.add_node!" href="#Qurt.Circuits.add_node!"><code>Qurt.Circuits.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_node!(qcircuit::Circuit, op::Element, wires::NTuple{&lt;:Any, IntT},
               clwires=()) where {IntT &lt;: Integer}

add_node!(qcircuit::Circuit, (op, params)::Tuple{Element, &lt;:Any},
                   wires::NTuple{&lt;:Any, IntT}, clwires=()) where {IntT &lt;: Integer}</code></pre><p>Add <code>op</code> or <code>(op, params)</code> to the back of <code>qcircuit</code> with the specified classical and quantum wires.</p><p>The new node is inserted between the output nodes and their current predecessor nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL424-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.compose" href="#Qurt.Circuits.compose"><code>Qurt.Circuits.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(qc_to::Circuit, qc_from::Circuit, quwires=1:num_wires(qc_from))</code></pre><p>Append <code>qc_from</code> to a copy of <code>qc_to</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL695-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.compose!" href="#Qurt.Circuits.compose!"><code>Qurt.Circuits.compose!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose!(qc_to::Circuit, qc_from::Circuit, wireorder=1:num_wires(qc_from))</code></pre><p>Append <code>qc_from</code> to <code>qc_to</code>.</p><p><code>wireorder</code> specifies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL705-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}" href="#Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}"><code>Qurt.Circuits.count_ops_longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_ops_longest_path(qc::Circuit)</code></pre><p>Return a count map of the circuit elements on a longest path in <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL947-L951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.global_phase-Tuple{Circuit}" href="#Qurt.Circuits.global_phase-Tuple{Circuit}"><code>Qurt.Circuits.global_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_phase(qc::Circuit)</code></pre><p>Return the global phase of <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL352-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.insert_node!" href="#Qurt.Circuits.insert_node!"><code>Qurt.Circuits.insert_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_node!(qcircuit::Circuit, op::Element, out_vertices, wires::NTuple{&lt;:Any, IntT},
               clwires=()) where {IntT &lt;: Integer}

add_node!(qcircuit::Circuit, (op, params)::Tuple{Element, &lt;:Any},
                   out_vertices, wires::NTuple{&lt;:Any, IntT}, clwires=()) where {IntT &lt;: Integer}</code></pre><p>Insert <code>op</code> or <code>(op, params)</code> to <code>qcircuit</code> before <code>out_vertices</code> on <code>wires</code> and <code>clwires</code>.</p><p><code>op</code> is wired into the circuit at pairs in <code>zip((wires..., clwires...), out_vertices)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL473-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.longest_path-Tuple{Circuit}" href="#Qurt.Circuits.longest_path-Tuple{Circuit}"><code>Qurt.Circuits.longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">longest_path(qc::Circuit)</code></pre><p>Compute a longest path of vertices in <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL940-L944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.nodes-Tuple{Circuit}" href="#Qurt.Circuits.nodes-Tuple{Circuit}"><code>Qurt.Circuits.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(qc::Circuit)</code></pre><p>Return the nodes in the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.num_tensor_factors-Tuple{Circuit}" href="#Qurt.Circuits.num_tensor_factors-Tuple{Circuit}"><code>Qurt.Circuits.num_tensor_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_tensor_factors(qc::Circuit)</code></pre><p>Return the number of tensor factors in an operator representation of <code>qc</code>.</p><p>The meaning of this in the presence of classical components is unclear.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Qurt.Circuits: Circuit, num_tensor_factors

julia&gt; num_tensor_factors(Circuit(3, 2))
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL903-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.param_map-Tuple{Circuit}" href="#Qurt.Circuits.param_map-Tuple{Circuit}"><code>Qurt.Circuits.param_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">param_map(qc::Circuit)</code></pre><p>Return the parameter map for <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.param_table-Tuple{Circuit}" href="#Qurt.Circuits.param_table-Tuple{Circuit}"><code>Qurt.Circuits.param_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">param_table(qc::Circuit)</code></pre><p>Return the parameter table for <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.predecessors-Tuple{Circuit, Any}" href="#Qurt.Circuits.predecessors-Tuple{Circuit, Any}"><code>Qurt.Circuits.predecessors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predecessors(qc::Circuit, vert)</code></pre><p>Return the predecessors of <code>vert</code> in <code>qc</code>. This does not return a copy, so mutation will mutate the graph as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL775-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}" href="#Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.quantum_successors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantum_successors(qc::Circuit, vert)</code></pre><p>Return the successors of <code>vert</code> in <code>qc</code> that are connnected by at least one quantum wire.</p><p>The return value is may or may not be a copy of node data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL791-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.remove_block!" href="#Qurt.Circuits.remove_block!"><code>Qurt.Circuits.remove_block!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_block!(qc::Circuit, vinds, [vmap])</code></pre><p>Remove the nodes in the block given by collection <code>vinds</code> and connect incoming and outgoing neighbors of the block on each wire. Assume the first and last elements are on incoming and outgoing wires to the block, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL614-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}" href="#Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}"><code>Qurt.Circuits.remove_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_node!(qc::Circuit, vind::Integer)</code></pre><p>Remove the node at vertex index <code>vind</code> and connect incoming and outgoing neighbors on each wire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL580-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.successors-Tuple{Circuit, Any}" href="#Qurt.Circuits.successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.successors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">successors(qc::Circuit, vert)</code></pre><p>Return the successors of <code>vert</code> in <code>qc</code>. This does not return a copy, so mutation will mutate the graph as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL783-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.topological_nodes-Tuple{Circuit}" href="#Qurt.Circuits.topological_nodes-Tuple{Circuit}"><code>Qurt.Circuits.topological_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topological_nodes(qc::Circuit)::AbstractVector{&lt;:Node}</code></pre><p>Return a topologically sorted vector of the nodes.</p><p>The returned data is a vector-of-structs view of the underlying data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL735-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.topological_vertices-Tuple{Circuit}" href="#Qurt.Circuits.topological_vertices-Tuple{Circuit}"><code>Qurt.Circuits.topological_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topological_vertices(qc::Circuit)::Vector{&lt;:Integer}</code></pre><p>Return a topologically sorted vector of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL728-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireelements" href="#Qurt.NodeStructs.wireelements"><code>Qurt.NodeStructs.wireelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wireelements(qc::Circuit,  wire::Integer, [init_vertex])</code></pre><p>Return an iterator over elements on <code>wire</code>.</p><p>Start on <code>init_vertex</code>, if supplied, rather than the circuit input vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL751-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireparamelements" href="#Qurt.NodeStructs.wireparamelements"><code>Qurt.NodeStructs.wireparamelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wireelements(qc::Circuit,  wire::Integer, [init_vertex])</code></pre><p>Return an iterator over elements on <code>wire</code>.</p><p>Start on <code>init_vertex</code>, if supplied, rather than the circuit input vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL764-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}" href="#Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}"><code>Qurt.NodeStructs.wirevertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wirevertices(qc::Circuit, wire::Integer)</code></pre><p>Return an iterator over ordered vertices on <code>wire</code> beginning with the input node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/circuits.jl#LL744-L748">source</a></section></article><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.isinvolution" href="#Qurt.Interface.isinvolution"><code>Qurt.Interface.isinvolution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isinvolution(obj)</code></pre><p>Return <code>true</code> if the <code>obj</code> is the inverse of <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.node" href="#Qurt.Interface.node"><code>Qurt.Interface.node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">node(qc, vert)
node(nodes, vert)
node(nodes, verts)</code></pre><p>Return the node on vertex <code>vert</code>, or collection <code>verts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_clbits" href="#Qurt.Interface.num_clbits"><code>Qurt.Interface.num_clbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_clbits(obj)
num_clbits(objs, i)</code></pre><p>Return the number of clbits associated with <code>obj</code> or with the <code>i</code>th element of the collection <code>objs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_qu_cl_bits-Tuple" href="#Qurt.Interface.num_qu_cl_bits-Tuple"><code>Qurt.Interface.num_qu_cl_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_qu_cl_bits(obj)
num_qu_cl_bits(objs, i)</code></pre><p>Return a <code>Tuple{Int, Int}</code> of number of quantum and classical bits associated with <code>obj</code> or the <code>i</code>th element of <code>objs</code>.</p><p>This may be more efficient than calling <code>num_qu_bits</code> and <code>num_cl_bits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_qubits" href="#Qurt.Interface.num_qubits"><code>Qurt.Interface.num_qubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_qubits(obj)
num_qubits(objs, i)</code></pre><p>Return the number of qubits associated with <code>obj</code> or with the <code>i</code>th element of the collection <code>objs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_wires" href="#Qurt.Interface.num_wires"><code>Qurt.Interface.num_wires</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_wires(obj)</code></pre><p>Return the number of wires (quantum and classical) in <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/interface.jl#LL74-L78">source</a></section></article><h2 id="Nodes"><a class="docs-heading-anchor" href="#Nodes">Nodes</a><a id="Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs" href="#Qurt.NodeStructs"><code>Qurt.NodeStructs</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module NodeStructs</code></pre><p>Manages data associated with vertices on a DAG. This includes node type, for example io, operator, etc. Also information on which wires pass through/terminate on the node/vertex and which neighboring vertices are on the wires.</p><p>The types used here are <code>Node</code> for a single node, and <code>StructVector{&lt;:Node}</code> for a &quot;struct of arrays&quot; collection.</p><p>We also have a roll-your-own struct of arrays <code>NodeArray</code> in node_array.jl. It is a bit more performant in many cases. But requires more maintenance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.NodeArray" href="#Qurt.NodeStructs.NodeArray"><code>Qurt.NodeStructs.NodeArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NodeArray</code></pre><p>Our custom struct-of-arrays collection of <code>Node</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_array.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F" href="#Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F"><code>Qurt.Interface.count_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_elements(testfunc::F, nodes::ANodeArrays)</code></pre><p>Count circuit elements for which <code>testfunc</code> returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL635-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}" href="#Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.inneighborind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighborind(nodes::ANodeArrays, node_ind::Integer, wire::Integer)</code></pre><p>Return a <code>Tuple{T,T}</code> of the in-neighbor of node <code>node_ind</code> on wire <code>wire</code> and the wire index of <code>wire</code> on that in-neighbor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL371-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}" href="#Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.multi_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_qubit_ops(nodes::ANodeArrays)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL692-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N" href="#Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N"><code>Qurt.NodeStructs.n_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_qubit_ops(nodes::ANodeArrays, n::Integer)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL667-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}" href="#Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}"><code>Qurt.NodeStructs.named_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">named_nodes(nodes::ANodeArrays, names...)</code></pre><p>Return a view of <code>nodes</code> containing all with name (<code>Element</code> type) in <code>names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL658-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.new_node_vector" href="#Qurt.NodeStructs.new_node_vector"><code>Qurt.NodeStructs.new_node_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_node_vector()</code></pre><p>Create an object for storing node information. This includes the element, parameters, information on wires and mapping wires to vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}" href="#Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.outneighborind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighborind(nodes::ANodeArrays, node_ind::Integer, wire::Integer)</code></pre><p>Return a <code>Tuple{T,T}</code> of the out-neighbor of node <code>node_ind</code> on wire <code>wire</code> and the wire index of <code>wire</code> on that out-neighbor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}" href="#Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}"><code>Qurt.NodeStructs.setinwire_ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setinwire_ind(nodes, vind_src, wireind, vind_dst)</code></pre><p>Set the inwire map of vertex <code>vind_src</code> on wire <code>wireind</code> to point to <code>vind_dst</code>.</p><p>Set the inneighbor of <code>vind_src</code> on <code>wireind</code> to <code>vind_dst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL222-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}" href="#Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.two_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">two_qubit_ops(nodes::ANodeArrays)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL678-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}" href="#Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireind(nodes, node_ind, wire::Integer)</code></pre><p>Return the index of wire number <code>wire</code> in the list of wires for node <code>node_ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}" href="#Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}"><code>Qurt.NodeStructs.wirevertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wirevertices(nodes, wire, init_vertex)</code></pre><p>Return an iterator over the ordered vertices in <code>nodes</code> on <code>wire</code> beginning with <code>init_vertex</code>.</p><p>The final output node is omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/node_structs.jl#LL311-L318">source</a></section></article><h2 id="Builders"><a class="docs-heading-anchor" href="#Builders">Builders</a><a id="Builders-1"></a><a class="docs-heading-anchor-permalink" href="#Builders" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders" href="#Qurt.Builders"><code>Qurt.Builders</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Builders</code></pre><p>Macro builder interface.</p><p>Build gates and circuits with macros <code>@build</code>, <code>@gate</code>, and <code>@gates</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/builders.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@build-Tuple" href="#Qurt.Builders.@build-Tuple"><code>Qurt.Builders.@build</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@build qcircuit gate1 gate2 ...</code></pre><p>Add circuit elements to <code>qcircuit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/builders.jl#LL70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@gate-Tuple{Any}" href="#Qurt.Builders.@gate-Tuple{Any}"><code>Qurt.Builders.@gate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gate GateName::Element
@gate GateName{param1, [pararam2,...]}
@gate GateName(wire1, [wire2,...])
@gate GateName{param1, [pararam2,...]}(wire1, [wire2,...])</code></pre><p>&quot;Build&quot; a gate.</p><p>There is no single object that represents a gate application. But it&#39;s convenient at times to work with a gate together with its parameters, or the wires that it is applied to. This macro actually packages this information about applying a gate into a struct, which can later be unpacked and inserted into a circuit. For example <code>add_node!</code> accepts types returned by <code>@gate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/builders.jl#LL129-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@gates-Tuple" href="#Qurt.Builders.@gates-Tuple"><code>Qurt.Builders.@gates</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gates gate1 gate2 ...</code></pre><p>Return a <code>Tuple</code> of gates where <code>gates1</code>, <code>gates2</code>, etc. follow the syntax required by <code>@gate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/ff6f3b81a980c1827bcd141ff66fb7c43ea9d1cb/src/builders.jl#LL143-L148">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Qurt.Builders"><code>Qurt.Builders</code></a></li><li><a href="#Qurt.Elements"><code>Qurt.Elements</code></a></li><li><a href="#Qurt.NodeStructs"><code>Qurt.NodeStructs</code></a></li><li><a href="#Qurt.Qurt"><code>Qurt.Qurt</code></a></li><li><a href="#Qurt.Elements.X"><code>Qurt.Elements.X</code></a></li><li><a href="#Qurt.Elements.Y"><code>Qurt.Elements.Y</code></a></li><li><a href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.Circuits.Circuit-Tuple{}"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.NodeStructs.NodeArray"><code>Qurt.NodeStructs.NodeArray</code></a></li><li><a href="internals/#Base.empty-Tuple{Circuit}"><code>Base.empty</code></a></li><li><a href="internals/#Graphs.inneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Graphs.inneighbors</code></a></li><li><a href="internals/#Graphs.inneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Graphs.inneighbors</code></a></li><li><a href="internals/#Graphs.outneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Graphs.outneighbors</code></a></li><li><a href="internals/#Graphs.outneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Graphs.outneighbors</code></a></li><li><a href="internals/#Qurt.Angle.isapprox_turn-Tuple{Qurt.Elements.ParamElement, Qurt.Elements.ParamElement}"><code>Qurt.Angle.isapprox_turn</code></a></li><li><a href="internals/#Qurt.Circuits.__add_io_node_data!-Tuple{Graphs.AbstractGraph, Any, Integer, Integer}"><code>Qurt.Circuits.__add_io_node_data!</code></a></li><li><a href="#Qurt.Circuits.add_node!"><code>Qurt.Circuits.add_node!</code></a></li><li><a href="internals/#Qurt.Circuits.check_param_table-Tuple{Any}"><code>Qurt.Circuits.check_param_table</code></a></li><li><a href="#Qurt.Circuits.compose"><code>Qurt.Circuits.compose</code></a></li><li><a href="#Qurt.Circuits.compose!"><code>Qurt.Circuits.compose!</code></a></li><li><a href="#Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}"><code>Qurt.Circuits.count_ops_longest_path</code></a></li><li><a href="#Qurt.Circuits.global_phase-Tuple{Circuit}"><code>Qurt.Circuits.global_phase</code></a></li><li><a href="#Qurt.Circuits.insert_node!"><code>Qurt.Circuits.insert_node!</code></a></li><li><a href="#Qurt.Circuits.longest_path-Tuple{Circuit}"><code>Qurt.Circuits.longest_path</code></a></li><li><a href="#Qurt.Circuits.nodes-Tuple{Circuit}"><code>Qurt.Circuits.nodes</code></a></li><li><a href="#Qurt.Circuits.num_tensor_factors-Tuple{Circuit}"><code>Qurt.Circuits.num_tensor_factors</code></a></li><li><a href="#Qurt.Circuits.param_map-Tuple{Circuit}"><code>Qurt.Circuits.param_map</code></a></li><li><a href="#Qurt.Circuits.param_table-Tuple{Circuit}"><code>Qurt.Circuits.param_table</code></a></li><li><a href="#Qurt.Circuits.predecessors-Tuple{Circuit, Any}"><code>Qurt.Circuits.predecessors</code></a></li><li><a href="#Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.quantum_successors</code></a></li><li><a href="#Qurt.Circuits.remove_block!"><code>Qurt.Circuits.remove_block!</code></a></li><li><a href="#Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}"><code>Qurt.Circuits.remove_node!</code></a></li><li><a href="#Qurt.Circuits.successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.successors</code></a></li><li><a href="#Qurt.Circuits.topological_nodes-Tuple{Circuit}"><code>Qurt.Circuits.topological_nodes</code></a></li><li><a href="#Qurt.Circuits.topological_vertices-Tuple{Circuit}"><code>Qurt.Circuits.topological_vertices</code></a></li><li><a href="internals/#Qurt.Interface.check-Tuple{Circuit}"><code>Qurt.Interface.check</code></a></li><li><a href="#Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F"><code>Qurt.Interface.count_elements</code></a></li><li><a href="internals/#Qurt.Interface.count_op_elements-Tuple{Circuit}"><code>Qurt.Interface.count_op_elements</code></a></li><li><a href="internals/#Qurt.Interface.count_ops_vertices-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Any}"><code>Qurt.Interface.count_ops_vertices</code></a></li><li><a href="internals/#Qurt.Interface.depth-Tuple{Circuit}"><code>Qurt.Interface.depth</code></a></li><li><a href="internals/#Qurt.Interface.getparam-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.Interface.getparam</code></a></li><li><a href="internals/#Qurt.Interface.iscustomgate"><code>Qurt.Interface.iscustomgate</code></a></li><li><a href="#Qurt.Interface.isinvolution"><code>Qurt.Interface.isinvolution</code></a></li><li><a href="#Qurt.Interface.node"><code>Qurt.Interface.node</code></a></li><li><a href="internals/#Qurt.Interface.num_clbits-Tuple{Circuit}"><code>Qurt.Interface.num_clbits</code></a></li><li><a href="#Qurt.Interface.num_clbits"><code>Qurt.Interface.num_clbits</code></a></li><li><a href="internals/#Qurt.Interface.num_parameters-Tuple{Circuit}"><code>Qurt.Interface.num_parameters</code></a></li><li><a href="#Qurt.Interface.num_qu_cl_bits-Tuple"><code>Qurt.Interface.num_qu_cl_bits</code></a></li><li><a href="internals/#Qurt.Interface.num_qubits-Tuple{Circuit}"><code>Qurt.Interface.num_qubits</code></a></li><li><a href="#Qurt.Interface.num_qubits"><code>Qurt.Interface.num_qubits</code></a></li><li><a href="#Qurt.Interface.num_wires"><code>Qurt.Interface.num_wires</code></a></li><li><a href="internals/#Qurt.NodeStructs.find_nodes-Union{Tuple{fieldnames}, Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{fieldnames}}} where {F, fieldnames}"><code>Qurt.NodeStructs.find_nodes</code></a></li><li><a href="#Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.inneighborind</code></a></li><li><a href="#Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.multi_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N"><code>Qurt.NodeStructs.n_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}"><code>Qurt.NodeStructs.named_nodes</code></a></li><li><a href="#Qurt.NodeStructs.new_node_vector"><code>Qurt.NodeStructs.new_node_vector</code></a></li><li><a href="internals/#Qurt.NodeStructs.one_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.one_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.outneighborind</code></a></li><li><a href="internals/#Qurt.NodeStructs.rewire_across_node!-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Qurt.NodeStructs.rewire_across_node!</code></a></li><li><a href="#Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}"><code>Qurt.NodeStructs.setinwire_ind</code></a></li><li><a href="#Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.two_qubit_ops</code></a></li><li><a href="internals/#Qurt.NodeStructs.unpackwires-Tuple{Any, Integer}"><code>Qurt.NodeStructs.unpackwires</code></a></li><li><a href="#Qurt.NodeStructs.wireelements"><code>Qurt.NodeStructs.wireelements</code></a></li><li><a href="#Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a></li><li><a href="internals/#Qurt.NodeStructs.wireind-Tuple{Circuit, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a></li><li><a href="#Qurt.NodeStructs.wireparamelements"><code>Qurt.NodeStructs.wireparamelements</code></a></li><li><a href="#Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}"><code>Qurt.NodeStructs.wirevertices</code></a></li><li><a href="#Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}"><code>Qurt.NodeStructs.wirevertices</code></a></li><li><a href="#Qurt.Builders.@build-Tuple"><code>Qurt.Builders.@build</code></a></li><li><a href="#Qurt.Builders.@gate-Tuple{Any}"><code>Qurt.Builders.@gate</code></a></li><li><a href="#Qurt.Builders.@gates-Tuple"><code>Qurt.Builders.@gates</code></a></li><li><a href="internals/#Qurt.Elements.@new_elements-Tuple{Any, Vararg{Any}}"><code>Qurt.Elements.@new_elements</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 27 April 2023 21:27">Thursday 27 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

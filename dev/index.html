<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Qurt.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Qurt.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Qurt"><span>Qurt</span></a></li><li><a class="tocitem" href="#Circuit-Elements"><span>Circuit Elements</span></a></li><li><a class="tocitem" href="#Circuits"><span>Circuits</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Nodes"><span>Nodes</span></a></li><li><a class="tocitem" href="#Builders"><span>Builders</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jlapeyre/Qurt.jl/blob/main/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Qurt.jl"><a class="docs-heading-anchor" href="#Qurt.jl">Qurt.jl</a><a id="Qurt.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Qurt.jl" title="Permalink"></a></h1><ul><li><a href="#Qurt.jl">Qurt.jl</a></li><li class="no-marker"><ul><li><a href="#Qurt">Qurt</a></li><li><a href="#Circuit-Elements">Circuit Elements</a></li><li><a href="#Circuits">Circuits</a></li><li><a href="#Interface">Interface</a></li><li><a href="#Nodes">Nodes</a></li><li><a href="#Builders">Builders</a></li><li><a href="#Index">Index</a></li></ul></li><li><a href="internals/#Internals">Internals</a></li><li class="no-marker"><ul><li><a href="internals/#Circuit-Elements-internals">Circuit Elements internals</a></li><li><a href="internals/#Circuits-internals">Circuits internals</a></li><li><a href="internals/#Wires-internals">Wires internals</a></li><li><a href="internals/#Interface-internals">Interface internals</a></li><li><a href="internals/#Nodes-internals">Nodes internals</a></li><li><a href="internals/#Builders-internals">Builders internals</a></li></ul></li></ul><h2 id="Qurt"><a class="docs-heading-anchor" href="#Qurt">Qurt</a><a id="Qurt-1"></a><a class="docs-heading-anchor-permalink" href="#Qurt" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Qurt" href="#Qurt.Qurt"><code>Qurt.Qurt</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Qurt</code></pre><p>The toplevel module of the package <code>Qurt</code> for building and manipulating quantum circuits. Documentation for <code>Qurt</code> is found in submodules.</p><p>There is apparently no way to include documentation from extension modules. There are two extension modules</p><ul><li><code>PythonCallExt</code> This extension will be loaded if you add <code>PythonCall</code> to your environment and load it.</li></ul><p>It defines methods <a href="#Qurt.Interface.to_qiskit"><code>to_qiskit</code></a> and <a href="#Qurt.Interface.draw"><code>draw</code></a> for <code>Qurt.Circuits.Circuit</code>. Some documentation has been added to <a href="@ref"><code>Interfaces</code></a> for this.</p><ul><li><code>GraphPlotExt</code> This extension will be loaded if you add <code>GraphPlot</code> to your environment and load it. It</li></ul><p>contains not-well-developed functions for drawing the <code>Qurt.Circuits.Circuit</code> as a DAG.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/Qurt.jl#LL1-L14">source</a></section></article><h2 id="Circuit-Elements"><a class="docs-heading-anchor" href="#Circuit-Elements">Circuit Elements</a><a id="Circuit-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-Elements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements" href="#Qurt.Elements"><code>Qurt.Elements</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Elements</code></pre><p>Quantum circuit elements. These are enums, that is encoded essentially as integers. There is a <code>struct</code> below <code>ParamElement</code> that composes an <code>Element</code> with a parameter, or container of parameters. This is meant to be any kind of parameter, not just an angle. But it is no meant to carry around metadata that is unrelated to paramaterizing a parametric gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/elements.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements.X" href="#Qurt.Elements.X"><code>Qurt.Elements.X</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">X::Element</code></pre><p>The <code>X</code> gate circuit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/elements.jl#LL300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Elements.Y" href="#Qurt.Elements.Y"><code>Qurt.Elements.Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Y::Element</code></pre><p>The <code>Y</code> gate circuit element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/elements.jl#LL307-L311">source</a></section></article><h2 id="Circuits"><a class="docs-heading-anchor" href="#Circuits">Circuits</a><a id="Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Circuits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits" href="#Qurt.Circuits"><code>Qurt.Circuits</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Circuits</code></pre><p>This module defines the struct <code>Circuit</code> to represent circuits and includes low-level functions for manipulating them. Functions in this module are often forwarded to, or use, functions in the module <a href="#Qurt.NodeStructs"><code>NodeStructs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit" href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circuit(nqubits::Integer, nclbits::Integer=0; global_phase=0.0)</code></pre><p>Create a circuit with <code>nqubits</code> qubits, <code>nclbits</code> clbits.</p><p>Pairs of input and output nodes connected by an edges are created for each quantum and classical bit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Qurt.Circuits: Circuit

julia&gt; Circuit(2, 2)
circuit {nq=2, ncl=2, nv=8, ne=4} Graphs.SimpleGraphs.SimpleDiGraph{Int64} Qurt.NodeStructs.Node{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL164-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit" href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Circuit</code></pre><p>Structure for representing a quantum circuit as a DAG with data attached to vertices and edges.</p><p><strong>Fields</strong></p><ul><li><code>graph</code> – The DAG as a <code>Graphs.DiGraph</code></li><li><code>nodes</code> – Operations and other nodes on vertices</li><li><code>nqubits</code> – Number of qubits.</li><li><code>nclbits</code> – Number of classical bits.</li></ul><p>The DAG is a <code>Graphs.DiGraph</code>, which maintains edge lists for forward and backward edges. An &quot;operation&quot; is associated with each vertex in the graph. Each vertex is identified by a positive integer. Each wire is identified by a positive integer.</p><p>The edge lists for vertex <code>i</code> are given by the <code>i</code>th element of the <code>Vector</code> of edge lists stored in the DAG.</p><p>The operation on vertex <code>i</code> is given by the <code>i</code>th element of the field <code>nodes</code>.</p><p>There is no meaning in the order of neighboring vertices in the edge lists, in fact they are sorted.</p><p>The number of wires is equal to <code>nqubits + nclbits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL115-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.Circuit-Tuple{}" href="#Qurt.Circuits.Circuit-Tuple{}"><code>Qurt.Circuits.Circuit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Circuit(;global_phase=0.0)</code></pre><p>Create a circuit with no qubits, no clbits, and global phase equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.add_node!" href="#Qurt.Circuits.add_node!"><code>Qurt.Circuits.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_node!(qcircuit::Circuit, op::Element, wires::NTuple{&lt;:Any, IntT},
               clwires=()) where {IntT &lt;: Integer}

add_node!(qcircuit::Circuit, (op, params)::Tuple{Element, &lt;:Any},
                   wires::NTuple{&lt;:Any, IntT}, clwires=()) where {IntT &lt;: Integer}</code></pre><p>Add <code>op</code> or <code>(op, params)</code> to the back of <code>qcircuit</code> with the specified classical and quantum wires.</p><p>The new node is inserted between the output nodes and their current predecessor nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL435-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.compose" href="#Qurt.Circuits.compose"><code>Qurt.Circuits.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(qc_to::Circuit, qc_from::Circuit, quwires=1:num_wires(qc_from))</code></pre><p>Append <code>qc_from</code> to a copy of <code>qc_to</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL706-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.compose!" href="#Qurt.Circuits.compose!"><code>Qurt.Circuits.compose!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose!(qc_to::Circuit, qc_from::Circuit, wireorder=1:num_wires(qc_from))</code></pre><p>Append <code>qc_from</code> to <code>qc_to</code>.</p><p><code>wireorder</code> specifies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL716-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}" href="#Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}"><code>Qurt.Circuits.count_ops_longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_ops_longest_path(qc::Circuit)</code></pre><p>Return a count map of the circuit elements on a longest path in <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL961-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.global_phase-Tuple{Circuit}" href="#Qurt.Circuits.global_phase-Tuple{Circuit}"><code>Qurt.Circuits.global_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_phase(qc::Circuit)</code></pre><p>Return the global phase of <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL363-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.insert_node!" href="#Qurt.Circuits.insert_node!"><code>Qurt.Circuits.insert_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_node!(qcircuit::Circuit, op::Element, out_vertices, wires::NTuple{&lt;:Any, IntT},
               clwires=()) where {IntT &lt;: Integer}

add_node!(qcircuit::Circuit, (op, params)::Tuple{Element, &lt;:Any},
                   out_vertices, wires::NTuple{&lt;:Any, IntT}, clwires=()) where {IntT &lt;: Integer}</code></pre><p>Insert <code>op</code> or <code>(op, params)</code> to <code>qcircuit</code> before <code>out_vertices</code> on <code>wires</code> and <code>clwires</code>.</p><p><code>op</code> is wired into the circuit at pairs in <code>zip((wires..., clwires...), out_vertices)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL484-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.longest_path-Tuple{Circuit}" href="#Qurt.Circuits.longest_path-Tuple{Circuit}"><code>Qurt.Circuits.longest_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">longest_path(qc::Circuit)</code></pre><p>Compute a longest path of vertices in <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL954-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.nodes-Tuple{Circuit}" href="#Qurt.Circuits.nodes-Tuple{Circuit}"><code>Qurt.Circuits.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(qc::Circuit)</code></pre><p>Return the nodes in the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL370-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.num_tensor_factors-Tuple{Circuit}" href="#Qurt.Circuits.num_tensor_factors-Tuple{Circuit}"><code>Qurt.Circuits.num_tensor_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_tensor_factors(qc::Circuit)</code></pre><p>Return the number of tensor factors in an operator representation of <code>qc</code>.</p><p>The meaning of this in the presence of classical components is unclear.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Qurt.Circuits: Circuit, num_tensor_factors

julia&gt; num_tensor_factors(Circuit(3, 2))
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL917-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.param_map-Tuple{Circuit}" href="#Qurt.Circuits.param_map-Tuple{Circuit}"><code>Qurt.Circuits.param_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">param_map(qc::Circuit)</code></pre><p>Return the parameter map for <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.param_table-Tuple{Circuit}" href="#Qurt.Circuits.param_table-Tuple{Circuit}"><code>Qurt.Circuits.param_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">param_table(qc::Circuit)</code></pre><p>Return the parameter table for <code>qc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.predecessors-Tuple{Circuit, Any}" href="#Qurt.Circuits.predecessors-Tuple{Circuit, Any}"><code>Qurt.Circuits.predecessors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predecessors(qc::Circuit, vert)</code></pre><p>Return the predecessors of <code>vert</code> in <code>qc</code>. This does not return a copy, so mutation will mutate the graph as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL786-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}" href="#Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.quantum_successors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantum_successors(qc::Circuit, vert)</code></pre><p>Return the successors of <code>vert</code> in <code>qc</code> that are connnected by at least one quantum wire.</p><p>The return value is may or may not be a copy of node data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL802-L808">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.remove_block!" href="#Qurt.Circuits.remove_block!"><code>Qurt.Circuits.remove_block!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_block!(qc::Circuit, vinds, [vmap])</code></pre><p>Remove the nodes in the block given by collection <code>vinds</code> and connect incoming and outgoing neighbors of the block on each wire. Assume the first and last elements are on incoming and outgoing wires to the block, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL625-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}" href="#Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}"><code>Qurt.Circuits.remove_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_node!(qc::Circuit, vind::Integer)</code></pre><p>Remove the node at vertex index <code>vind</code> and connect incoming and outgoing neighbors on each wire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL591-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.successors-Tuple{Circuit, Any}" href="#Qurt.Circuits.successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.successors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">successors(qc::Circuit, vert)</code></pre><p>Return the successors of <code>vert</code> in <code>qc</code>. This does not return a copy, so mutation will mutate the graph as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL794-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.topological_nodes-Tuple{Circuit}" href="#Qurt.Circuits.topological_nodes-Tuple{Circuit}"><code>Qurt.Circuits.topological_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topological_nodes(qc::Circuit)::AbstractVector{&lt;:Node}</code></pre><p>Return a topologically sorted vector of the nodes.</p><p>The returned data is a vector-of-structs view of the underlying data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL746-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Circuits.topological_vertices-Tuple{Circuit}" href="#Qurt.Circuits.topological_vertices-Tuple{Circuit}"><code>Qurt.Circuits.topological_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">topological_vertices(qc::Circuit)::Vector{&lt;:Integer}</code></pre><p>Return a topologically sorted vector of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL739-L743">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireelements" href="#Qurt.NodeStructs.wireelements"><code>Qurt.NodeStructs.wireelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wireelements(qc::Circuit,  wire::Integer, [init_vertex])</code></pre><p>Return an iterator over elements on <code>wire</code>.</p><p>Start on <code>init_vertex</code>, if supplied, rather than the circuit input vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL762-L768">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireparamelements" href="#Qurt.NodeStructs.wireparamelements"><code>Qurt.NodeStructs.wireparamelements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wireelements(qc::Circuit,  wire::Integer, [init_vertex])</code></pre><p>Return an iterator over elements on <code>wire</code>.</p><p>Start on <code>init_vertex</code>, if supplied, rather than the circuit input vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL775-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}" href="#Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}"><code>Qurt.NodeStructs.wirevertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wirevertices(qc::Circuit, wire::Integer)</code></pre><p>Return an iterator over ordered vertices on <code>wire</code> beginning with the input node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/circuits.jl#LL755-L759">source</a></section></article><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface" href="#Qurt.Interface"><code>Qurt.Interface</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Interface</code></pre><p>This module exports functions that have methods defined in more than one module. It may evolve into a module for functions in the highest API. It&#39;s also a bit of a dumping ground at the moment for functions that may better belong elsewhere. For convenience some of the heavily used functions are imported and reexported from the top level of this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.count_ops" href="#Qurt.Interface.count_ops"><code>Qurt.Interface.count_ops</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_ops(obj)</code></pre><p>Return a count_map (<code>Dictionary</code>) of the ops in an object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.count_wires" href="#Qurt.Interface.count_wires"><code>Qurt.Interface.count_wires</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_wires(qcirc)
count_wires(obj)</code></pre><p>Return a count map the number of nodes with <code>(nqu, ncl)</code> qubits and classical bits for each value of the <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.draw" href="#Qurt.Interface.draw"><code>Qurt.Interface.draw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">draw(qc::Circuit, args...)</code></pre><p>Use Python qiskit to draw <code>qc</code>.</p><p>Some arguments <code>arg</code> will work as expected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.isinvolution" href="#Qurt.Interface.isinvolution"><code>Qurt.Interface.isinvolution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isinvolution(obj)</code></pre><p>Return <code>true</code> if the <code>obj</code> is the inverse of <code>obj</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.node" href="#Qurt.Interface.node"><code>Qurt.Interface.node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">node(qc, vert)
node(nodes, vert)
node(nodes, verts)</code></pre><p>Return the node on vertex <code>vert</code>, or collection <code>verts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_clbits" href="#Qurt.Interface.num_clbits"><code>Qurt.Interface.num_clbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_clbits(obj)
num_clbits(objs, i)</code></pre><p>Return the number of clbits associated with <code>obj</code> or with the <code>i</code>th element of the collection <code>objs</code>.</p><p>This function should have a method for any object where it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_inwires" href="#Qurt.Interface.num_inwires"><code>Qurt.Interface.num_inwires</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_inwires(obj)
num_inwires(obj, i)</code></pre><p>Return the number of incoming wires (quantum and classical) in <code>obj</code> or in the <code>i</code>th element of the collection <code>objs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_outwires" href="#Qurt.Interface.num_outwires"><code>Qurt.Interface.num_outwires</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_outwires(obj)
num_outwires(obj, i)</code></pre><p>Return the number of outgoing wires (quantum and classical) in <code>obj</code> or in the <code>i</code>th element of the collection <code>objs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_parameters" href="#Qurt.Interface.num_parameters"><code>Qurt.Interface.num_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_parameters(obj)
num_parameters(obj, i)</code></pre><p>Return the number of parameters associated with <code>obj</code> or with the <code>i</code>th element of the collection <code>objs</code>.</p><p>This function should have a method for any object where it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_qu_cl_bits-Tuple" href="#Qurt.Interface.num_qu_cl_bits-Tuple"><code>Qurt.Interface.num_qu_cl_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_qu_cl_bits(obj)
num_qu_cl_bits(objs, i)</code></pre><p>Return a <code>Tuple{Int, Int}</code> of number of quantum and classical bits associated with <code>obj</code> or the <code>i</code>th element of <code>objs</code>.</p><p>This may be more efficient than calling <code>num_qu_bits</code> and <code>num_cl_bits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_qubits" href="#Qurt.Interface.num_qubits"><code>Qurt.Interface.num_qubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_qubits(obj)
num_qubits(objs, i)</code></pre><p>Return the number of qubits associated with <code>obj</code> or with the <code>i</code>th element of the collection <code>objs</code>.</p><p>This function should have a method for any object where it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.num_wires" href="#Qurt.Interface.num_wires"><code>Qurt.Interface.num_wires</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_wires(obj)</code></pre><p>Return the number of wires (quantum and classical) in <code>obj</code> or in the <code>i</code>th element of the collection <code>objs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.to_qiskit" href="#Qurt.Interface.to_qiskit"><code>Qurt.Interface.to_qiskit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_qiskit(qcircuit)</code></pre><p>Convert <code>qcircuit</code> to a Qiskit <code>QuantumCircuit</code>.</p><p>You must add package <code>PythonCall</code> to your project and load it before using <code>to_qiskit</code>. Only a relatively small portion of <code>QuantumCircuit</code> is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/interface.jl#LL52-L60">source</a></section></article><h2 id="Nodes"><a class="docs-heading-anchor" href="#Nodes">Nodes</a><a id="Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs" href="#Qurt.NodeStructs"><code>Qurt.NodeStructs</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module NodeStructs</code></pre><p>This module Manages data associated with vertices on a DAG. This includes node type, for example io, operator, etc. Also information on which wires pass through/terminate on the node/vertex and which neighboring vertices are on the wires.</p><p>The types used here are <code>Node</code> for a single node, and <code>StructVector{&lt;:Node}</code> for a &quot;struct of arrays&quot; collection.</p><p>We also have a roll-your-own struct of arrays <code>NodeArray</code> in node_array.jl. It is a bit more performant in many cases. But requires more maintenance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.NodeArray" href="#Qurt.NodeStructs.NodeArray"><code>Qurt.NodeStructs.NodeArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NodeArray</code></pre><p>Our custom struct-of-arrays collection of <code>Node</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_array.jl#LL7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F" href="#Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F"><code>Qurt.Interface.count_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_elements(testfunc::F, nodes::ANodeArrays)</code></pre><p>Count circuit elements for which <code>testfunc</code> returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}" href="#Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.inneighborind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighborind(nodes::ANodeArrays, node_ind::Integer, wire::Integer)</code></pre><p>Return a <code>Tuple{T,T}</code> of the in-neighbor of node <code>node_ind</code> on wire <code>wire</code> and the wire index of <code>wire</code> on that in-neighbor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL375-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}" href="#Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.multi_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multi_qubit_ops(nodes::ANodeArrays)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL696-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N" href="#Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N"><code>Qurt.NodeStructs.n_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_qubit_ops(nodes::ANodeArrays, n::Integer)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL671-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}" href="#Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}"><code>Qurt.NodeStructs.named_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">named_nodes(nodes::ANodeArrays, names...)</code></pre><p>Return a view of <code>nodes</code> containing all with name (<code>Element</code> type) in <code>names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL662-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.new_node_vector" href="#Qurt.NodeStructs.new_node_vector"><code>Qurt.NodeStructs.new_node_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_node_vector()</code></pre><p>Create an object for storing node information. This includes the element, parameters, information on wires and mapping wires to vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}" href="#Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.outneighborind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighborind(nodes::ANodeArrays, node_ind::Integer, wire::Integer)</code></pre><p>Return a <code>Tuple{T,T}</code> of the out-neighbor of node <code>node_ind</code> on wire <code>wire</code> and the wire index of <code>wire</code> on that out-neighbor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL365-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}" href="#Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}"><code>Qurt.NodeStructs.setinwire_ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setinwire_ind(nodes, vind_src, wireind, vind_dst)</code></pre><p>Set the inwire map of vertex <code>vind_src</code> on wire <code>wireind</code> to point to <code>vind_dst</code>.</p><p>Set the inneighbor of <code>vind_src</code> on <code>wireind</code> to <code>vind_dst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}" href="#Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.two_qubit_ops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">two_qubit_ops(nodes::ANodeArrays)</code></pre><p>Return a view of <code>nodes</code> containing all with two qubit wires.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL682-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}" href="#Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireind(nodes, node_ind, wire::Integer)</code></pre><p>Return the index of wire number <code>wire</code> in the list of wires for node <code>node_ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}" href="#Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}"><code>Qurt.NodeStructs.wirevertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wirevertices(nodes, wire, init_vertex)</code></pre><p>Return an iterator over the ordered vertices in <code>nodes</code> on <code>wire</code> beginning with <code>init_vertex</code>.</p><p>The final output node is omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/node_structs.jl#LL315-L322">source</a></section></article><h2 id="Builders"><a class="docs-heading-anchor" href="#Builders">Builders</a><a id="Builders-1"></a><a class="docs-heading-anchor-permalink" href="#Builders" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders" href="#Qurt.Builders"><code>Qurt.Builders</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Builders</code></pre><p>This module contains circuit and gate builders implemented as macros</p><p>Build gates and circuits with macros <a href="#Qurt.Builders.@build-Tuple"><code>@build</code></a>, <a href="#Qurt.Builders.@gate-Tuple{Any}"><code>@gate</code></a>, and <a href="#Qurt.Builders.@gates-Tuple"><code>@gates</code></a>.</p><p>Note that <code>@gate</code> actually constructs not only gates, but any circuit element, such as <code>Measure</code> and <code>Barrier</code>. In particular, the following syntax applies to all circuit elements. (Perhaps <code>@gate</code> should be renamed)</p><p>A structure representing a gate <code>G</code> applied at wires <code>(i, [j,...])</code> is constructed with the syntax <code>G(i, [j,...])</code>. Quantum and classical wires are separated with a semicolon. Gate parameters <code>(p1, [p2,...])</code> are associated with a gate via curly brackets like this <code>G{p1, [p2,...]}</code>. Both wires and parameters are associated by combining this syntax like this <code>G{p1, [p2,...]}(i, [j,...])</code></p><p>For example</p><pre><code class="language-julia hljs">@gate X(1)  # gate and wire
@gate CX(2, 3) # gate and wires
@gate RX{1.5}  # gate and parameters
@gate RX{1.5}(2) # gate, parameters, and wire
@gate Measure(1, 2; 3, 4) # Circuit element and quantum and classical wires</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/builders.jl#LL1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@build-Tuple" href="#Qurt.Builders.@build-Tuple"><code>Qurt.Builders.@build</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@build qcircuit gate1 gate2 ...</code></pre><p>Add circuit elements to <code>qcircuit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/builders.jl#LL91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@gate-Tuple{Any}" href="#Qurt.Builders.@gate-Tuple{Any}"><code>Qurt.Builders.@gate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gate GateName::Element
@gate GateName{param1, [pararam2,...]}
@gate GateName(wire1, [wire2,...])
@gate GateName{param1, [pararam2,...]}(wire1, [wire2,...])</code></pre><p>&quot;Build&quot; a gate.</p><p>There is no single object that represents a gate application. But it&#39;s convenient at times to work with a gate together with its parameters, or the wires that it is applied to. This macro actually packages this information about applying a gate into a struct, which can later be unpacked and inserted into a circuit. For example <code>add_node!</code> accepts types returned by <code>@gate</code>. See also <a href="#Qurt.Builders.@gates-Tuple"><code>@gates</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/builders.jl#LL150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qurt.Builders.@gates-Tuple" href="#Qurt.Builders.@gates-Tuple"><code>Qurt.Builders.@gates</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gates gate1 gate2 ...</code></pre><p>Return a <code>Tuple</code> of gates where <code>gates1</code>, <code>gates2</code>, etc. follow the syntax required by <code>@gate</code>. See <a href="#Qurt.Builders.@gate-Tuple{Any}"><code>@gate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlapeyre/Qurt.jl/blob/b8d407a02327be261da512c8240ef9ad547e99c5/src/builders.jl#LL164-L169">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Qurt.Builders"><code>Qurt.Builders</code></a></li><li><a href="#Qurt.Circuits"><code>Qurt.Circuits</code></a></li><li><a href="#Qurt.Elements"><code>Qurt.Elements</code></a></li><li><a href="#Qurt.Interface"><code>Qurt.Interface</code></a></li><li><a href="#Qurt.NodeStructs"><code>Qurt.NodeStructs</code></a></li><li><a href="#Qurt.Qurt"><code>Qurt.Qurt</code></a></li><li><a href="#Qurt.Elements.X"><code>Qurt.Elements.X</code></a></li><li><a href="#Qurt.Elements.Y"><code>Qurt.Elements.Y</code></a></li><li><a href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.Circuits.Circuit"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.Circuits.Circuit-Tuple{}"><code>Qurt.Circuits.Circuit</code></a></li><li><a href="#Qurt.NodeStructs.NodeArray"><code>Qurt.NodeStructs.NodeArray</code></a></li><li><a href="internals/#Qurt.WiresMod.Wires"><code>Qurt.WiresMod.Wires</code></a></li><li><a href="internals/#Base.empty-Tuple{Circuit}"><code>Base.empty</code></a></li><li><a href="internals/#Graphs.inneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Graphs.inneighbors</code></a></li><li><a href="internals/#Graphs.inneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Graphs.inneighbors</code></a></li><li><a href="internals/#Graphs.outneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Graphs.outneighbors</code></a></li><li><a href="internals/#Graphs.outneighbors-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Graphs.outneighbors</code></a></li><li><a href="internals/#Qurt.Angle.isapprox_turn-Tuple{Qurt.Elements.ParamElement, Qurt.Elements.ParamElement}"><code>Qurt.Angle.isapprox_turn</code></a></li><li><a href="internals/#Qurt.Circuits.__add_io_node_data!-Tuple{Graphs.AbstractGraph, Any, Integer, Integer}"><code>Qurt.Circuits.__add_io_node_data!</code></a></li><li><a href="#Qurt.Circuits.add_node!"><code>Qurt.Circuits.add_node!</code></a></li><li><a href="internals/#Qurt.Circuits.check_param_table-Tuple{Any}"><code>Qurt.Circuits.check_param_table</code></a></li><li><a href="#Qurt.Circuits.compose"><code>Qurt.Circuits.compose</code></a></li><li><a href="#Qurt.Circuits.compose!"><code>Qurt.Circuits.compose!</code></a></li><li><a href="#Qurt.Circuits.count_ops_longest_path-Tuple{Circuit}"><code>Qurt.Circuits.count_ops_longest_path</code></a></li><li><a href="#Qurt.Circuits.global_phase-Tuple{Circuit}"><code>Qurt.Circuits.global_phase</code></a></li><li><a href="#Qurt.Circuits.insert_node!"><code>Qurt.Circuits.insert_node!</code></a></li><li><a href="#Qurt.Circuits.longest_path-Tuple{Circuit}"><code>Qurt.Circuits.longest_path</code></a></li><li><a href="#Qurt.Circuits.nodes-Tuple{Circuit}"><code>Qurt.Circuits.nodes</code></a></li><li><a href="#Qurt.Circuits.num_tensor_factors-Tuple{Circuit}"><code>Qurt.Circuits.num_tensor_factors</code></a></li><li><a href="#Qurt.Circuits.param_map-Tuple{Circuit}"><code>Qurt.Circuits.param_map</code></a></li><li><a href="#Qurt.Circuits.param_table-Tuple{Circuit}"><code>Qurt.Circuits.param_table</code></a></li><li><a href="#Qurt.Circuits.predecessors-Tuple{Circuit, Any}"><code>Qurt.Circuits.predecessors</code></a></li><li><a href="#Qurt.Circuits.quantum_successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.quantum_successors</code></a></li><li><a href="#Qurt.Circuits.remove_block!"><code>Qurt.Circuits.remove_block!</code></a></li><li><a href="#Qurt.Circuits.remove_node!-Tuple{Circuit, Integer}"><code>Qurt.Circuits.remove_node!</code></a></li><li><a href="#Qurt.Circuits.successors-Tuple{Circuit, Any}"><code>Qurt.Circuits.successors</code></a></li><li><a href="#Qurt.Circuits.topological_nodes-Tuple{Circuit}"><code>Qurt.Circuits.topological_nodes</code></a></li><li><a href="#Qurt.Circuits.topological_vertices-Tuple{Circuit}"><code>Qurt.Circuits.topological_vertices</code></a></li><li><a href="internals/#Qurt.Interface.check-Tuple{Circuit}"><code>Qurt.Interface.check</code></a></li><li><a href="#Qurt.Interface.count_elements-Union{Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}} where F"><code>Qurt.Interface.count_elements</code></a></li><li><a href="internals/#Qurt.Interface.count_op_elements-Tuple{Circuit}"><code>Qurt.Interface.count_op_elements</code></a></li><li><a href="#Qurt.Interface.count_ops"><code>Qurt.Interface.count_ops</code></a></li><li><a href="internals/#Qurt.Interface.count_ops_vertices-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Any}"><code>Qurt.Interface.count_ops_vertices</code></a></li><li><a href="#Qurt.Interface.count_wires"><code>Qurt.Interface.count_wires</code></a></li><li><a href="internals/#Qurt.Interface.depth-Tuple{Circuit}"><code>Qurt.Interface.depth</code></a></li><li><a href="#Qurt.Interface.draw"><code>Qurt.Interface.draw</code></a></li><li><a href="internals/#Qurt.Interface.getparam-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.Interface.getparam</code></a></li><li><a href="internals/#Qurt.Interface.iscustomgate"><code>Qurt.Interface.iscustomgate</code></a></li><li><a href="#Qurt.Interface.isinvolution"><code>Qurt.Interface.isinvolution</code></a></li><li><a href="#Qurt.Interface.node"><code>Qurt.Interface.node</code></a></li><li><a href="#Qurt.Interface.num_clbits"><code>Qurt.Interface.num_clbits</code></a></li><li><a href="internals/#Qurt.Interface.num_clbits-Tuple{Circuit}"><code>Qurt.Interface.num_clbits</code></a></li><li><a href="#Qurt.Interface.num_inwires"><code>Qurt.Interface.num_inwires</code></a></li><li><a href="#Qurt.Interface.num_outwires"><code>Qurt.Interface.num_outwires</code></a></li><li><a href="internals/#Qurt.Interface.num_parameters-Tuple{Circuit}"><code>Qurt.Interface.num_parameters</code></a></li><li><a href="#Qurt.Interface.num_parameters"><code>Qurt.Interface.num_parameters</code></a></li><li><a href="#Qurt.Interface.num_qu_cl_bits-Tuple"><code>Qurt.Interface.num_qu_cl_bits</code></a></li><li><a href="#Qurt.Interface.num_qubits"><code>Qurt.Interface.num_qubits</code></a></li><li><a href="internals/#Qurt.Interface.num_qubits-Tuple{Circuit}"><code>Qurt.Interface.num_qubits</code></a></li><li><a href="#Qurt.Interface.num_wires"><code>Qurt.Interface.num_wires</code></a></li><li><a href="#Qurt.Interface.to_qiskit"><code>Qurt.Interface.to_qiskit</code></a></li><li><a href="internals/#Qurt.NodeStructs.find_nodes-Union{Tuple{fieldnames}, Tuple{F}, Tuple{F, Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{fieldnames}}} where {F, fieldnames}"><code>Qurt.NodeStructs.find_nodes</code></a></li><li><a href="#Qurt.NodeStructs.inneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.inneighborind</code></a></li><li><a href="#Qurt.NodeStructs.multi_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.multi_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.n_qubit_ops-Union{Tuple{N}, Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Val{N}}} where N"><code>Qurt.NodeStructs.n_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.named_nodes-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Vararg{Any}}"><code>Qurt.NodeStructs.named_nodes</code></a></li><li><a href="#Qurt.NodeStructs.new_node_vector"><code>Qurt.NodeStructs.new_node_vector</code></a></li><li><a href="internals/#Qurt.NodeStructs.one_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.one_qubit_ops</code></a></li><li><a href="#Qurt.NodeStructs.outneighborind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer}"><code>Qurt.NodeStructs.outneighborind</code></a></li><li><a href="internals/#Qurt.NodeStructs.rewire_across_node!-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer}"><code>Qurt.NodeStructs.rewire_across_node!</code></a></li><li><a href="#Qurt.NodeStructs.setinwire_ind-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}, Integer, Integer, Integer}"><code>Qurt.NodeStructs.setinwire_ind</code></a></li><li><a href="#Qurt.NodeStructs.two_qubit_ops-Tuple{Union{Qurt.NodeStructs.NodeArray, StructArrays.StructVector{&lt;:Qurt.NodeStructs.Node}}}"><code>Qurt.NodeStructs.two_qubit_ops</code></a></li><li><a href="internals/#Qurt.NodeStructs.unpackwires-Tuple{Any, Integer}"><code>Qurt.NodeStructs.unpackwires</code></a></li><li><a href="#Qurt.NodeStructs.wireelements"><code>Qurt.NodeStructs.wireelements</code></a></li><li><a href="#Qurt.NodeStructs.wireind-Tuple{Any, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a></li><li><a href="internals/#Qurt.NodeStructs.wireind-Tuple{Circuit, Integer, Integer}"><code>Qurt.NodeStructs.wireind</code></a></li><li><a href="#Qurt.NodeStructs.wireparamelements"><code>Qurt.NodeStructs.wireparamelements</code></a></li><li><a href="#Qurt.NodeStructs.wirevertices-Tuple{Circuit, Any}"><code>Qurt.NodeStructs.wirevertices</code></a></li><li><a href="#Qurt.NodeStructs.wirevertices-Tuple{Any, Any, Any}"><code>Qurt.NodeStructs.wirevertices</code></a></li><li><a href="#Qurt.Builders.@build-Tuple"><code>Qurt.Builders.@build</code></a></li><li><a href="#Qurt.Builders.@gate-Tuple{Any}"><code>Qurt.Builders.@gate</code></a></li><li><a href="#Qurt.Builders.@gates-Tuple"><code>Qurt.Builders.@gates</code></a></li><li><a href="internals/#Qurt.Elements.@new_elements-Tuple{Any, Vararg{Any}}"><code>Qurt.Elements.@new_elements</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 29 April 2023 19:11">Saturday 29 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
